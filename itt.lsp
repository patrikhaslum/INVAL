
;;;;
;; Invariant Testing Tools (experimental).

;; Example (from sokoban-ae.pddl):
;; (invariant-test-1 '((?x . object) (?y . object))
;;                   '(imply (and (man ?x) (man ?y)) (= ?x ?y))
;;                   (cdr (first *actions*)))

(defun invariant-test-1 (fvars form actdef)
  (let* ((avars (cdr (assoc ':parameters actdef)))
	 (vmap (rename-variables avars fvars))
	 (rn-def (sublis vmap actdef)))
    (list 'forall
	  (unparse-typed-list (append fvars (sublis vmap avars)))
	  (list 'imply
		(merge-conjunctions form (cdr (assoc ':precondition rn-def)))
		(regress-formula form rn-def)))
    ))

(defun print-otter (stream form)
  (cond ((and (eq (first form) 'and) (rest form))
	 (format stream "(")
	 (print-otter stream (first (rest form)))
	 (dolist (c (rest (rest form)))
	   (format stream " & ")
	   (print-otter stream c))
	 (format stream ")"))
	((and (eq (first form) 'or) (rest form))
	 (format stream "(")
	 (print-otter stream (first (rest form)))
	 (dolist (c (rest (rest form)))
	   (format stream " | ")
	   (print-otter stream c))
	 (format stream ")"))
	((eq (first form) 'imply)
	 (format stream "(")
	 (print-otter stream (second form))
	 (format stream " -> ")
	 (print-otter stream (third form))
	 (format stream ")"))
	((eq (first form) 'not)
	 (format stream "-")
	 (print-otter stream (second form)))
	((eq (first form) 'forall)
	 (format stream "(all")
	 (dolist (v (parse-typed-list nil (second form) 'object))
	   (format stream " ~a" (variable-name (car v))))
	 (format stream " ")
	 (print-otter stream (third form))
	 (format stream ")"))
	((eq (first form) 'exists)
	 (format stream "(exists")
	 (dolist (v (parse-typed-list nil (second form) 'object))
	   (format stream " ~a" (variable-name (car v))))
	 (format stream " ")
	 (print-otter stream (third form))
	 (format stream ")"))
	((and (eq (first form) '=)
	      (variable-p (second form))
	      (variable-p (third form)))
	 (format stream "(~a = ~a)"
		 (variable-name (second form))
		 (variable-name (third form))))
	((and (listp form) (every #'variable-p (rest form)))
	 (format stream "~a(" (first form))
	 (cond ((rest form)
		(format stream "~a" (variable-name (first (rest form))))
		(dolist (a (rest (rest form)))
		  (format stream ",~a" (variable-name a)))))
	 (format stream ")"))
	(t (error "can't print ~s" form))
	))

(defun invariant-vars (inv)
  (parse-typed-list nil (cdr (assoc ':vars inv)) 'object))

(defun invariant-formula (inv)
  (let ((fo (assoc ':formula inv))
	(sc (assoc ':set-constraint inv)))
    (cond (fo (cdr fo))
	  (sc (set-constraint-formula (cdr sc)))
	  (t nil)
	  )))

;; (defun invariant-formula (inv)
;;   (let ((qv (assoc ':vars inv))
;; 	(fo (assoc ':formula inv))
;; 	(sc (assoc ':set-constraint inv)))
;;     (cond (fo (cond (qv (list 'forall qv (cdr fo)))
;; 		    (t (cdr fo))))
;; 	  (sc (set-constraint-formula (cdr sc) qv))
;; 	  (t nil)
;; 	  )))

;; (defun set-constraint-formula (sc vars)
;;   (if (not (eq (second sc) 1))
;;       (error "can't translate set constraint ~s" sc))
;;   (cond ((eq (first sc) 'at-most-n)
;; 	 (at-most-one-formula (rest (rest sc)) vars))
;; 	((eq (first sc) 'at-least-n)
;; 	 (at-least-one-formula (rest (rest sc)) vars))
;; 	((eq (first sc) 'exactly-n)
;; 	 (merge-conjunctions
;; 	  (at-most-one-formula (rest (rest sc)) vars)
;; 	  (at-least-one-formula (rest (rest sc)) vars)))
;; 	(t (error "ill-formed set constraint: ~s" sc))
;; 	))

;; (defun enumerate-disjunctions (atoms neg vars)
;;   (cond ((endp atoms) nil)
;; 	((eq (first (first atoms)) 'setof)
;; 	 (cons (...)
;; 	       (mapcar #'(lambda (a)
;; 			   (make-disjunction (first atoms) a neg vars))
;; 		       (rest atoms))))
;; 	(t (mapcar #'(lambda (a)
;; 		       (make-disjunction (first atoms) a neg vars))
;; 		   (rest atoms)))
;; 	))

;; (defun make-disjunction (atom1 atom2 neg vars)
;;   (cond ((and (eq (first atom1) 'setof)
;; 	      (eq (first atom2) 'setof))
;; 	 (let ((lvars
;; 		(append
;; 		 (parse-typed-list nil vars 'object)
;; 		 (parse-typed-list nil (cdr (assoc ':vars atom1)) 'object)
;; 		 (parse-typed-list nil (cdr (assoc ':vars atom2)) 'object)))
;; 	       (d1 (merge-conjunctions (cdr (assoc ':context atom1))
;; 				       (first (last atom1))))
;; 	       (d2 (merge-conjunctions (cdr (assoc ':context atom2))
;; 				       (first (last atom2)))))
;; 	   (list 'forall (unparse-typed-list lvars)
;; 		 (list 'or (if neg (list 'not d1) d1)
;; 		       (if neg (list 'not d2) d2)))))
;; 	((eq (first atom1) 'setof)
;; 	 (let ((lvars
;; 		(append
;; 		 (parse-typed-list nil vars 'object)
;; 		 (parse-typed-list nil (cdr (assoc ':vars atom1)) 'object)))
;; 	       (d1 (merge-conjunctions (cdr (assoc ':context atom1))
;; 				       (first (last atom1)))))
;; 	   (list 'forall (unparse-typed-list lvars)
;; 		 (list 'or (if neg (list 'not d1) d1)
;; 		       (if neg (list 'not atom2) atom2)))))
;; 	((eq (first atom2) 'setof)
;; 	 (make-disjunction atom2 atom1 neg vars))
;; 	(vars
;; 	 (list 'forall vars
;; 	       (list 'or (if neg (list 'not atom1) atom1)
;; 		     (if neg (list 'not atom2) atom2))))
;; 	(t (list 'or (if neg (list 'not atom1) atom1)
;; 		 (if neg (list 'not atom2) atom2)))
;; 	))


(defun regress-formula (form actdef)
  (cond
   ((null form) ':true)
   ((member (car form) '(and or not imply))
    (cons (car form)
	  (mapcar #'(lambda (f1) (regress-formula f1 actdef)) (cdr form))))
   ((member (car form) '(forall exists))
    (if (not (= (length form) 3)) (error "ill-formed formula: ~s" form))
    (list (car form) (second form) (regress-formula (third form) actdef)))
   ((eq (car form) '=) form)
   ((assoc (car form) *builtin-numeric-predicates*) form)
   ;; note: this implements DBA semantics; if an action makes the atom
   ;; true, it doesn't have to avoid making it false.
   (t (let ((ctrue (make-atom-true form actdef)))
	(cond (ctrue
	       (list 'or ctrue
		     (merge-conjunctions
		      form (not-make-atom-false form actdef))))
	      (t (merge-conjunctions
		  form (not-make-atom-false form actdef))))))
   ))

(defun make-atom-true (atom actdef)
  (let ((adds (collect-adds (cdr (assoc ':effect actdef)))))
    (reduce #'merge-disjunctions
	    (mapcar #'(lambda (add)
			(let ((binds (unify atom (first add))))
			  (if binds
			      (let ((econd
				     (make-effect-condition
				      (first binds) (second add) (third add))))
				(if econd econd ':true))
			    nil)))
		    adds)
	    :initial-value nil)))

(defun not-make-atom-false (atom actdef)
  (let ((dels (collect-dels (cdr (assoc ':effect actdef)))))
    (reduce #'merge-conjunctions
	    (mapcar #'(lambda (del)
			(let ((binds (unify atom (first del))))
			  (if binds
			      (let ((econd 
				     (make-effect-condition
				      (first binds) (second del) (third del))))
				(if econd (list 'not econd) ':false))
			    nil)))
		    dels)
	    :initial-value nil)))

(defun unify (e1 e2)
  (cond ((and (consp e1) (consp e2))
	 (let ((b1 (unify (car e1) (car e2))))
	   (if b1 (let ((b2 (unify (cdr e1) (cdr e2))))
		    (if b2 (list (append (car b1) (car b2))) nil))
	     nil)))
	((variable-p e2)
	 (list (list (cons e1 e2))))
	((variable-p e1)
	 (list (list (cons e1 e2))))
	((equal e1 e2) (list nil))
	(t nil)))

(defun make-effect-condition (binds econd qvars)
  (cond ((endp binds) econd)
	(t (let ((qv (assoc (cdr (first binds)) qvars)))
	     (cond (qv
		    (cond ((not (eq (cdr qv) 'object))
			   (merge-conjunctions
			    (list (cdr qv) (car (first binds)))
			    (sublis (list (cons (cdr (first binds))
						(car (first binds))))
				    (make-effect-condition
				     (rest binds) econd qvars))))
			  (t (sublis (list (cons (cdr (first binds))
						(car (first binds))))
				     (make-effect-condition
				      (rest binds) econd qvars)))
			  ))
		   (t (merge-conjunctions
		       (list '= (car (first binds)) (cdr (first binds)))
		       (make-effect-condition (rest binds) econd qvars)))
		   )))
	))

(defun collect-adds (eff)
  (cond
   ((null eff) nil)
   ((eq (car eff) 'not) nil)
   ((member (car eff) '(increase decrease assign)) nil)
   ((eq (car eff) 'and)
    (mapflat #'(lambda (e1) (collect-adds e1)) (rest eff)))
   ((eq (car eff) 'when)
    (mapcar #'(lambda (c1)
		(list (first c1)
		      (merge-conjunctions (second eff) (second c1))
		      (third c1)))
	    (collect-adds (third eff))))
   ((eq (car eff) 'forall)
    (let ((vars (parse-typed-list nil (second eff) 'object)))
      (mapcar #'(lambda (c1)
		  (list (first c1) (second c1) vars))
	      (collect-adds (third eff)))))
   (t (list (list eff nil nil)))
   ))

(defun collect-dels (eff)
  (cond
   ((null eff) nil)
   ((eq (car eff) 'not)
    (list (list (second eff) nil nil)))
   ((member (car eff) '(increase decrease assign)) nil)
   ((eq (car eff) 'and)
    (mapflat #'(lambda (e1) (collect-dels e1)) (rest eff)))
   ((eq (car eff) 'when)
    (mapcar #'(lambda (c1)
		(list (first c1)
		      (merge-conjunctions (second eff) (second c1))
		      (third c1)))
	    (collect-dels (third eff))))
   ((eq (car eff) 'forall)
    (let ((vars (parse-typed-list nil (second eff) 'object)))
      (mapcar #'(lambda (c1)
		  (list (first c1) (second c1) vars))
	      (collect-dels (third eff)))))
   (t nil)
   ))
